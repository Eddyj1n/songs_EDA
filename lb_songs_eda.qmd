---
title: "Lifeblood Take-home Assignment"
format: html
editor: visual
---

#### 0.1 Import data and load required packages

```{r}
# Install pacman if not already installed
if (!require("pacman")) install.packages("pacman")

# Clear worksapce 
rm(list=ls())

# Load the required packages using pacman
pacman::p_load(tidyverse,
               #plot packages
               ggplot2, psych, ggcorrplot, highcharter,plotly,ggpubr,viridis)

# Read in data set and parse date column as date objects 
songs_df <- read.csv("data/lifeblood_interview_dataset.csv") %>%  
  mutate(date = as.Date(date))

# Check information of data frame 
print(head(songs_df))
print(str(songs_df))
```

#### 1.1 Data preprocessing: Check for Duplicates

-   From inspection there appears to be 205 duplicates of songs

```{r}
# Assert if unique count of songs matches number of rows 
print(nrow(songs_df) == length(unique(songs_df)))
print(length(unique(songs_df$songs_id)))

# Duplicate songs exist, return the rows with the duplicate songs 
duplicate_songs_df  <- songs_df %>% 
  filter(duplicated(song_id) | duplicated(song_id, fromLast= TRUE ))

# Verify these songs are exact duplicates by checking other columns match the duplicates
duplicate_songs_df_verified <- duplicate_songs_df %>% 
  group_by(song_id) %>% 
  #If all columns have a distinct count of 1 for a particular song_id, it indicates that the duplicate songs are exact duplicates across all columns.
  summarize(across(everything(), ~n_distinct(.)))
```

#### 1.1 Data preprocessing: Check for missing values

There are 2329 missing values for energy in column. We make the assumption that these random values are completely missing at random (MCAR)

For future exploration, employ statistical test or ask data owner whether the missing values are missing at random (MAR), missing completely at random (MCAR), or missing not at random (MNAR).

```{r}
# Count the number of NULL and NA values column wise 
missing_values_df <- songs_df %>% 
  summarise_all(~sum(is.na(.)))
```

#### 1.1 Data preprocessinge: Check for outliers

We first remove duplicate values and remove missing values given our MCAR assumption. Then plot the distributions of each feature.

From visually inspecting the distributions, there appears to be negative observations in the 'length' variable which is physically impossible. Assuming this a data error, we remove these values moving forward. Again, with more time we can impute these incorrect values or ask the data owner for clarification.

```{r}
# Remove duplicates and missing values
cleaned_songs_df <- songs_df %>%
  distinct() %>%  
  filter(!is.na(energy))

# Plot the smoothed distribution of continuous variables  
variables <- setdiff(names(cleaned_songs_df) ,c("band_id", "genre", "song_id", "date"))

for (vars in variables) {
  plot <- ggplot(cleaned_songs_df, aes(x = !!sym(vars))) +
    geom_density(fill = "blue", alpha = 0.5) +
    ggtitle(paste("Density plot of", vars)) +
    theme_minimal()
  print(plot)
}

# Filter length rows to contain values greater than 0 
cleaned_songs_df <-cleaned_songs_df %>% 
  filter(length > 0)

```

#### 2.0 Exploratory data analysis: Calculate summary statistics

```{r}
# Calculate summary statistics for continuous variable and return data frame 
describe(cleaned_songs_df %>% select(all_of(variables))) %>%  
  select(mean, median, min, max, range, sd)
```

#### 2.1 Exploratory data analysis: Investigate temporal patterns across total songs at quarterly and yearly frequency to motivate what temporal features to include

A key observation there is a overall downward trend in the total amount of copies sold. This suggests `copies_sold` reflect the units sold since launch date of song. From here we assume the `copies_sold` variable is a cumulative sum of the copies sold since the launch date of the song.

```{r}
# Plot time series of total songs sold at the quarterly frequency
songs_quarterly_series_df <-cleaned_songs_df %>%
  mutate(year_quarter = paste0(year(date), "-Q", quarter(date))) %>%
  group_by(year_quarter) %>%
  summarize(total_songs_sold = sum(copies_sold))

hchart(songs_quarterly_series_df, "line", hcaes(x = year_quarter, y = total_songs_sold)) %>%
  hc_title(text = "Quarterly Total Songs Sold Over Time") %>%
  hc_xAxis(title = list(text = "Year-Quarter")) %>%
  hc_yAxis(title = list(text = "Total Songs Sold")) %>%
  hc_tooltip(valueDecimals = 0)

# Plot time series of total songs sold at the yearly frequency
songs_yearly_series_df <-cleaned_songs_df %>%
  mutate(year = format(date, "%Y")) %>%
  group_by(year) %>%
  summarize(total_songs_sold = sum(copies_sold))

# Create the highcharter plot object
hchart(songs_yearly_series_df, "line", hcaes(x = year, y = total_songs_sold)) %>%
  hc_title(text = "Yearly Total Songs Sold Over Time") %>%
  hc_xAxis(title = list(text = "Year")) %>%
  hc_yAxis(title = list(text = "Total Songs Sold")) %>%
  hc_tooltip(valueDecimals = 0)

# Plot time series of total songs sold by genre at the quarterly frequency
songs_genre_quarterly_series_df <- cleaned_songs_df %>%
  mutate(year_quarter = paste0(year(date), "-Q", quarter(date))) %>%
  group_by(year_quarter, genre) %>%
  summarize(total_songs_sold = sum(copies_sold))

# Create the highcharter plot object
hchart(songs_genre_quarterly_series_df, "line", hcaes(x = year_quarter, y = total_songs_sold, group = genre)) %>%
  hc_title(text = "Quarterly Total Songs Sold Over Time by Genre") %>%
  hc_xAxis(title = list(text = "Year-Quarter")) %>%
  hc_yAxis(title = list(text = "Total Songs Sold")) %>%
  hc_tooltip(valueDecimals = 0) %>%
  hc_legend(title = list(text = "Genre"))
```

#### 2.2 Investigate temporal patterns - Observe if there is seasonality present at weekly, monthly and quarterly frequency

**Objective:** To see whether it is important include seasonal dummies for the models, we plot the seasonal plots of copies_sold at each frequency.

**Findings:** There appears to no strong visual evidence of seasonality, note that there is a dip in week *53* because there are relatively less rows in week 53.

```{r}
# Plot the seasonal plots at the weekly, monthly and quarterly level for all the years 

# Add columns for week, quarter, month and year 
songs_time_index_df <- cleaned_songs_df %>%  
  mutate(year = year(date), 
         quarter = quarter(date),
         month = month(date),
         week = week(date))

# Define the frequencies and their corresponding columns
frequencies <- c("week", "month", "quarter")
frequency_cols <- list(week = "week", month = "month", quarter = "quarter")

# Loop through each frequency and generate plots
for (freq in frequencies) {
  col_name <- frequency_cols[[freq]]
  
  # Aggregate data at the current frequency
  aggregated_data <- songs_time_index_df %>%
    group_by(year, !!sym(col_name)) %>%
    summarize(total_copies_sold = round(sum(copies_sold)))

  # Generate plot for the current frequency
  plot <- hchart(aggregated_data, "line", hcaes(x = !!sym(col_name), y =  total_copies_sold, group = year)) %>%
    hc_colors(colors = viridis(length(unique(aggregated_data$year)))) %>%
    hc_title(text = paste(toupper(freq), "Copies Sold by Year")) %>%
    hc_xAxis(title = list(text = toupper(freq)),
             labels = list(step = 2)) %>%
    hc_yAxis(title = list(text = "Total Copies Sold")) %>%
    hc_legend(title = list(text = "Year")) %>%
    hc_tooltip(crosshairs = TRUE, shared = TRUE) %>%
    hc_exporting(enabled = TRUE)
  
  # Print the plot
  print(plot)
}

```

#### 2.2 Investigate temporal patterns - Plot the total loudness, energy and length at the quarterly level

Findings:

-   All series appears to be quite stable across time where `total_energy`, `total_loudness` exhibit a slight downward trend.

-   All series exhibit a uptick at towards the end of the time series

-   There is high correlation amongst the features

```{r}
# Aggreate target and features at each frequency and plot 
# Create time series df at the monthly frequency
features_weekly_df <- cleaned_songs_df %>%
  mutate(date = format(date, "%Y-%W")) %>%
  group_by(date) %>%
  summarize(total_copies_sold = sum(copies_sold),
            total_loudness = sum(loudness),
            total_energy = sum(energy),
            total_length = sum(length)) %>%
  arrange(date) 

# Create time series df at the monthly frequency
features_monthly_df <- cleaned_songs_df %>%
  mutate(date = format(date, "%Y-%m")) %>%
  group_by(date) %>%
  summarize(total_copies_sold = sum(copies_sold),
            total_loudness = sum(loudness),
            total_energy = sum(energy),
            total_length = sum(length)) %>%
  arrange(date) 

# Create time series df at the quarterly frequency
features_quarterly_df <-cleaned_songs_df %>%
  mutate(date = paste0(year(date), "-Q", quarter(date))) %>%
  group_by(date) %>%
    summarize(total_copies_sold = sum(copies_sold),
            total_loudness = sum(loudness),
            total_energy = sum(energy),
            total_length = sum(length)) %>%
  arrange(date)

# Create a list to store the dataframes
features_list <- list(
  weekly = features_weekly_df,
  monthly = features_monthly_df,
  quarterly = features_quarterly_df
)

# Loop through the frequencies and create the plots
for (freq in names(features_list)) {
  features_df <- features_list[[freq]]  # Corrected variable name
  
  plot <- hchart(features_df, "line", hcaes(x = date, y = total_loudness), name = "Total Loudness") %>%
    hc_add_series(features_df, "line", hcaes(x = date, y = total_energy), name = "Total Energy") %>%
    hc_add_series(features_df, "line", hcaes(x = date, y = total_length), yAxis = 1, name = "Total Length") %>%
    hc_add_series(features_df, "line", hcaes(x = date, y = 10*total_copies_sold), yAxis = 1, name = "Total Copies Sold") %>%
    hc_title(text = paste("Features and target", freq)) %>%
    hc_xAxis(title = list(text = "Date")) %>%
    hc_yAxis_multiples(list(title = list(text = "Loudness/Energy"),
                            opposite = FALSE),
                       list(title = list(text = "Length/Copies Sold"),
                            opposite = TRUE)) %>%
    hc_tooltip(valueDecimals = 0)
  
  print(plot)
}
```

#### 2.3 EDA: Perform different counts on the data relating to target

We perform the following counts:

-   **Check**: Number of songs that sold above 2 million and the count to see if there is class imbalance.
    -   **Findings:** As the proportion of songs sold above 2 million only covers \~6% of the data, recommend using regression approach.
-   **Check**: Total count of songs released in each year in aggregate and by genre.
    -   **Findings:**
        -   Aggregate songs released in year is overall decreasing
        -   Folktronica features releases the most songs by year consistent with the amount of copies sold
-   **Check**: Total count of songs released by band in across all time to see if there are any data anomalies and whether it's feasible to train a model at the band level
    -   **Findings:** There are 1390 unique bands and 7970 observations, where most bands have released less than 5 songs. Insufficient degrees of freedom to estimate a statistical model, pivot to *genre* level.

```{r}
# Calculate the proportion of song that  sold above 2 million 
proportion_songs_above_2m <-cleaned_songs_df %>% 
  summarize(proportion_songs_above_2m = sum(copies_sold >= 2) / nrow(.))

# Calculate total count of songs released in each year in aggregate by genre 
songs_yearly_count_df <-cleaned_songs_df %>% 
  mutate(year = year(date)) %>%
  group_by(year, genre) %>%
  summarize(total_songs_released = n())

# Create a stacked bar chart across time of the count songs for each genre 
hchart(songs_yearly_count_df, "column", hcaes(x = year, y = total_songs_released, group = genre)) %>%
  hc_title(text = "Yearly Total Songs Released by Genre") %>%
  hc_xAxis(title = list(text = "Year")) %>%
  hc_yAxis(title = list(text = "Total Songs Released")) %>%
  hc_tooltip(valueDecimals = 0)

# Create a stacked bar chart across time of the count songs for each genre
hchart(songs_yearly_count_df, "column", hcaes(x = year, y = total_songs_released, group = genre), stacking = "normal") %>%
  hc_title(text = "Yearly Total Songs Released by Genre") %>%
  hc_xAxis(title = list(text = "Year")) %>%
  hc_yAxis(title = list(text = "Total Songs Released")) %>%
  hc_tooltip(valueDecimals = 0)

# Calculate count of songs released by band in across all time 
songs_band_count_df <- cleaned_songs_df %>%  
  group_by(band_id) %>%
  summarise(total_songs_released = n()) %>%  
  arrange(desc(total_songs_released))

# Plot distribution of frequency on number of songs released at band level 
ggplot(songs_band_count_df, aes(x = total_songs_released)) +
  geom_histogram(binwidth = 1, fill = "blue", alpha = 0.5) +
  ggtitle("Distribution of Frequency of Number of Songs Released by Band") +
  theme_minimal()

# Caclulate total count of unique bands
unique_bands_count <- cleaned_songs_df %>% 
  summarize(unique_bands = n_distinct(band_id))
```

#### 2.4 EDA: Plot distributions of each features across year

Investigate if there are any temporal patterns/anomalies at the yearly levels. Findings: The distributions of the continuous features are relatively stable across the years.

```{r}
# Plot the smoothed distributions of the continuous features for each year 
for (vars in variables) {
  plot <- ggplot(cleaned_songs_df, aes(x = !!sym(vars), fill = as.factor(year(date)))) +
    geom_density(alpha = 0.5) +
    ggtitle(paste("Density plot of", vars)) +
    theme_minimal()
  print(plot)
}

# Plot the violin plots of each continuous feature for each year 
for (vars in variables) {
  plot <- plot_ly(cleaned_songs_df, x = ~as.factor(year(date)), y = ~get(vars), type = "violin",
                  box = list(visible = TRUE),
                  meanline = list(visible = TRUE),
                  hoverinfo = "text" ) %>%
    layout(title = paste("Violin Plot of", vars),
           xaxis = list(title = "Year"),
           yaxis = list(title = vars),
           showlegend = FALSE)
  print(plot)
}
```

#### 3.0 Feature engineering: Create new features

Before continuing eda, we build some new features

To build model to predict the number of copies sold, we create the following features:

-   Days since launch date of song

```{r}
# Assume record day is last day of data set 
record_date = max(cleaned_songs_df$date)

# Create days since launch feature 
cleaned_songs_df <- cleaned_songs_df %>% 
  mutate(days_since_launch = as.integer(difftime(record_date, date, units = "days")))

# Append days_since_launch to variables vector 
variables <- c(variables, "days_since_launch")
aggregated_variables <-names(features_weekly_df)[2:5]
  
```

#### 2.5 EDA: Plot correlation and interaction of features with target variable

**Check:** Investigate the correlation amongst features to understand feature importance.

**Findings:**

-   There appears to be low correlation at the song level but high correlation at the weekly level.

-   For model A we need to model it on the song level

-   For model B when modelling for the genre of songs, consider modelling at weekly frequency

-   In particular length seems to have low correlation with the target variable, copies_sold and other features

```{r}
# Calculate correlation matrix for continuous variables at different levels
# Correlation matrix at the song level 
correlation_matrix_song_level <- cor(cleaned_songs_df %>% select(all_of(variables)))

# Correlation matrix at the weekly level
correlation_matrix_weekly <- cor(features_weekly_df %>%  select(all_of(aggregated_variables)))

# Plot correlation matrices 
ggcorrplot(correlation_matrix_song_level, hc.order = TRUE, type = "upper",lab = TRUE)
ggcorrplot(correlation_matrix_weekly, hc.order = TRUE, type = "upper",lab = TRUE)

# Plot a scatter plot of energy vs. copies sold
ggplot(data = cleaned_songs_df %>% sample_n(1000),
                       aes(x = energy, y = copies_sold, color = genre, size = days_since_launch)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "loess", formula = y ~ x, color = "black", size = 1) +
  scale_color_viridis(discrete = TRUE) +
  labs(x = "energy", y = "Copies Sold", title = "Scatter Plot of Energy vs. Copies Sold") +
  theme_minimal() 


# Plot a scatter plot of length vs. copies sold
ggplot(data = cleaned_songs_df %>% sample_n(1000),
                       aes(x = length, y = copies_sold, color = genre, size = days_since_launch)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", formula = y ~ x, color = "black", size = 1) +
  scale_color_viridis(discrete = TRUE) +
  labs(x = "length", y = "Copies Sold", title = "Scatter Plot of Energy vs. Copies Sold") +
  theme_minimal() 

# Plot a scatter plot of loudness vs. copies sold
ggplot(data = cleaned_songs_df %>% sample_n(1000),
                       aes(x = loudness, y = copies_sold, color = genre, size = days_since_launch)) +
  geom_point(alpha = 0.7) +
  geom_smooth(method = "lm", formula = y ~ x, color = "black", size = 1) +
  scale_color_viridis(discrete = TRUE) +
  labs(x = "loudness", y = "Copies Sold", title = "Scatter Plot of Energy vs. Copies Sold") +
  theme_minimal() 


```
