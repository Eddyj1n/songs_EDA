---
title: "Lifeblood Take-home Assignment"
author: Eddy Jin 
format: html
editor: visual
---

#### Executive - Overall Approach

The exploratory data analysis (EDA) is conducted to motivate the model building process. Based on the EDA, the two models are proposed to balance between the complexity to solve the problem and the ease of bringing the model to production.

For **Model A**: - Assuming we are to predict the whether a *new* song will sell more than two million copies we run a random forest regression where `copies_sold` is the target and the features are :

-   `loudness`, `energy`, `length`

-   one-hot encoding of `genre`

-   `days_since_launch_date` (new feature)

For **Model B** - Assuming the model is to evaluate the popularity of a genre over sequential time periods *historically* and **not** used to forecast future popularity (which will require a time-series approach). Based off the EDA we can use multivariate regression specified below.

$$
y\_{it} = \beta\_0 + \beta\_1 X\_{it1} + \beta\_2 X\_{it2} + \dots + \beta\_k X\_{itk} + \alpha\_g + t + \epsilon\_{it}
$$ {#eq-1}

Where $y\_{it}$ is the copies sold for song $i$ in genre $g$ at time $t$, $X\_{it}$ are the features, $\alpha\_g$ is the genre fixed effect, $\Y_d$ is the time fixed effect for each year, and $\epsilon\_{it}$ is the error term.

Consideration: Using song-level data at the level may result in too much noise, can aggregate at weekly level to run panel model. A mixed-effects model can be explored to capture the hierarchical structure of data, however EDA suggests there may insufficient observations at the band level.

**Data Assumptions**:

-   `copies_sold` is the amount sold since release date recorded at the end of the data set.
-   All missing values and non-nonsensical values are assumed to be missing completely at random (MCAR).

#### 1. Import data and load required packages

```{r}
#| echo: false
# Install pacman if not already installed
if (!require("pacman")) install.packages("pacman")

# Clear workspace 
rm(list=ls())

# Load the required packages using pacman
pacman::p_load(tidyverse,ggplot2, psych, ggcorrplot, highcharter,plotly,viridis)

# Read in data set and parse date column as date objects 
songs_df <- read.csv("data/lifeblood_interview_dataset.csv") %>%  
  mutate(date = as.Date(date))

# Check information of data frame 
print(head(songs_df))
print(str(songs_df))

```

#### 2. Data pre-processing:

In this section we assess the hygiene of the data but checking the following:

-   Duplicate rows

-   Missing values

-   Outliers or nonsensical data points

##### 2.1: Check for duplicate rows

```{r}
# Assert if unique count of songs matches number of rows 
print(nrow(songs_df) == length(unique(songs_df)))

# Duplicate songs exist, return the rows with the duplicate songs 
duplicate_songs_df  <- songs_df %>% 
  filter(duplicated(song_id) | duplicated(song_id, fromLast= TRUE ))

# Verify these songs are exact duplicates by checking other columns match the duplicates
duplicate_songs_df_verified <- duplicate_songs_df %>% 
  group_by(song_id) %>% 
  
#If all columns have a distinct count of 1 for a particular song_id, it indicates that the duplicate songs are exact duplicates across all columns.
  summarize(across(everything(), ~n_distinct(.)))
```

##### 2.2: Check for missing values

```{r}
# Count the number of NULL and NA values column wise 
missing_values_df <- songs_df %>% 
  summarise_all(~sum(is.na(.)))

missing_values_df
```

##### 2.3: Check for outliers

```{r}
# Remove duplicates and missing values
cleaned_songs_df <- songs_df %>%
  distinct() %>%  
  filter(!is.na(energy))

# Plot the smoothed distribution of continuous variables  
variables <- c("copies_sold", "length", "energy", "loudness")
              
for (vars in variables) {
  plot <- ggplot(cleaned_songs_df, aes(x = !!sym(vars))) +
    geom_density(fill = "blue", alpha = 0.5) +
    ggtitle(paste("Density plot of", vars)) +
    theme_minimal()
  print(plot)
}

# Filter length rows to contain values greater than 0 
cleaned_songs_df <-cleaned_songs_df %>% 
  filter(length > 0)

```

**Findings:**

-   There are 205 duplicates of songs

-   The energy column has 2329 missing values, assumed to be missing completely at random (MCAR).

    Future exploration: Use statistical tests or consult the data owner to determine if the missing values are missing at random (MAR), MCAR, or missing not at random (MNAR).

-   We first remove duplicate values and missing values given our MCAR assumption. Then plot the distributions of each feature.

    -   Visual inspection of the distributions reveals negative observations in the 'length' variable, which is physically impossible. Assuming this is a data error, these values are removed for further analysis.
    -   Future improvement: Impute incorrect values or seek clarification from the data owner.

### 3.0 Exploratory data analysis:

#### 3.1 Calculate summary statistics

We calculate the summary statistics for the continuous variables to familirise with the distribution of the data.

```{r}
# Calculate summary statistics for continuous variable and return data frame 
describe(cleaned_songs_df %>% select(all_of(variables))) %>%  
  select(mean, median, min, max, range, sd)
```

#### 3.2 Perform different counts on the data for modelling considerations

We perform the following analyses:

1.  **Check**: Count the number of songs that sold above 2 million copies to assess potential class imbalance.

    -   **Findings**: Only \~6% of the songs sold above 2 million copies, suggesting that a regression approach may be more appropriate than a classification approach due to class imbalance.

2.  **Check**: Count the total number of songs released each year, both in aggregate and by genre.

    -   **Findings**:

        -   The aggregate number of songs released per year is generally decreasing.

        -   The Folktronica genre consistently releases the most songs each year

3.  **Check**: Count the total number of songs released by each band across all time to identify any data anomalies and assess the feasibility of training a model at the band level.

    -   **Findings**: There are 1,390 unique bands and 7,970 observations, with most bands having released fewer than 5 songs. Due to low degrees of freedom can be difficult to estimate the effect of bands.

4.  **Check**: Each band only produces the same genre of songs to check hierarchical structure of data

    -   **Findings**: All bands in the data set produce the same genre of songs.

```{r}
# Calculate the proportion of song that  sold above 2 million 
proportion_songs_above_2m <-cleaned_songs_df %>% 
  summarize(proportion_songs_above_2m = sum(copies_sold >= 2) / nrow(.))

# Calculate total count of songs released in each year in aggregate by genre 
songs_yearly_count_df <-cleaned_songs_df %>% 
  mutate(year = year(date)) %>%
  group_by(year, genre) %>%
  summarize(total_songs_released = n())

# Create a stacked bar chart across time of the count songs for each genre 
hchart(songs_yearly_count_df, "column", hcaes(x = year, y = total_songs_released, group = genre)) %>%
  hc_title(text = "Yearly Total Songs Released by Genre") %>%
  hc_xAxis(title = list(text = "Year")) %>%
  hc_yAxis(title = list(text = "Total Songs Released")) %>%
  hc_tooltip(valueDecimals = 0)

# Create a stacked bar chart across time of the count songs for each genre
hchart(songs_yearly_count_df, "column", hcaes(x = year, y = total_songs_released, group = genre), stacking = "normal") %>%
  hc_title(text = "Yearly Total Songs Released by Genre") %>%
  hc_xAxis(title = list(text = "Year")) %>%
  hc_yAxis(title = list(text = "Total Songs Released")) %>%
  hc_tooltip(valueDecimals = 0)

# Calculate count of songs released by band in across all time 
songs_band_count_df <- cleaned_songs_df %>%  
  group_by(band_id) %>%
  summarise(total_songs_released = n()) %>%  
  arrange(desc(total_songs_released))

# Plot distribution of frequency on number of songs released at band level 
ggplot(songs_band_count_df, aes(x = total_songs_released)) +
  geom_histogram(binwidth = 1, fill = "blue", alpha = 0.5) +
  ggtitle("Distribution of Frequency of Number of Songs Released by Band") +
  theme_minimal()

# Calculate total count of unique bands
unique_bands_count <- cleaned_songs_df %>% 
  summarize(unique_bands = n_distinct(band_id))

# Check if each band only produces the same genre of songs
band_genre_count <- cleaned_songs_df %>% 
  group_by(band_id) %>% 
  summarize(unique_genres = n_distinct(genre)) %>% 
  filter(unique_genres > 1)
```

#### 3.2 Investigate temporal patterns across total songs and songs released at quarterly and yearly frequency

-   Total songs released and total copies_sold are highly correlated at the quarterly frequency at \~0.95%.

-   The `copies_sold` variable shows an more pronounced downward trend than total songs released. This is suggestive that it represents the cumulative units sold since each song's launch date. We assume that copies_sold is a cumulative sum of the copies sold since the release of the song.

-   Folktronica genre is appears to be dominating the market share in terms of `copies_sold` aligning with our results above.

```{r}
# Plot time series of total songs sold and songs released at the quarterly frequency
songs_quarterly_series_df <- cleaned_songs_df %>%
  mutate(year_quarter = paste0(year(date), "-Q", quarter(date))) %>%
  group_by(year_quarter) %>%
  summarize(total_songs_sold = sum(copies_sold),
            total_songs_released = n())

# Plot time series of total songs sold and released at the quarterly frequency
hchart(songs_quarterly_series_df, "line", hcaes(x = year_quarter, y = total_songs_sold)) %>%
  hc_title(text = "Quarterly Total Songs Sold and Released Over Time") %>%
  hc_xAxis(title = list(text = "Year-Quarter")) %>%
  hc_yAxis_multiples(
    list(title = list(text = "Total Songs Sold")),
    list(title = list(text = "Total Songs Released"), opposite = TRUE)
  ) %>%
  hc_add_series(songs_quarterly_series_df$total_songs_released, name = "Total Songs Released", type = "line", yAxis = 1)

# Calculate correlation between total songs sold and total songs released at qtrly frequency 
print(cor(songs_quarterly_series_df$total_songs_sold, songs_quarterly_series_df$total_songs_released))

# Plot time series of total songs sold at the yearly frequency
songs_yearly_series_df <-cleaned_songs_df %>%
  mutate(year = format(date, "%Y")) %>%
  group_by(year) %>%
  summarize(total_songs_sold = sum(copies_sold),
             total_songs_released = n())
            
# Create the highcharter plot object
hchart(songs_yearly_series_df, "line", hcaes(x = year, y = total_songs_sold)) %>%
  hc_title(text = "Yearly Total Songs Sold Over Time") %>%
  hc_xAxis(title = list(text = "Year")) %>%
  hc_yAxis_multiples(
    list(title = list(text = "Total Songs Sold")),
    list(title = list(text = "Total Songs Released"), opposite = TRUE)
  ) %>%
  hc_add_series(songs_yearly_series_df$total_songs_released, name = "Total Songs Released", type = "line", yAxis = 1)

# Plot time series of total songs sold by genre at the quarterly frequency
songs_genre_quarterly_series_df <- cleaned_songs_df %>%
  mutate(year_quarter = paste0(year(date), "-Q", quarter(date))) %>%
  group_by(year_quarter, genre) %>%
  summarize(total_songs_sold = sum(copies_sold))

# Create the highcharter plot object
hchart(songs_genre_quarterly_series_df, "line", hcaes(x = year_quarter, y = total_songs_sold, group = genre)) %>%
  hc_title(text = "Quarterly Total Songs Sold Over Time by Genre") %>%
  hc_xAxis(title = list(text = "Year-Quarter")) %>%
  hc_yAxis(title = list(text = "Total Songs Sold")) %>%
  hc_tooltip(valueDecimals = 0) %>%
  hc_legend(title = list(text = "Genre"))
```

#### 3.3 Investigate whether seasonality exists at the weekly, monthly or quarterly level for our target

**Objective:** To determine the importance of including seasonal dummy variables in the models, we create seasonal plots of `copies_sold` at different frequencies.

**Findings:** The seasonal plots do not provide strong visual evidence of seasonality in the copies_sold variable. It is worth noting that there is a dip in week 53, which can be attributed to the relatively fewer number of rows corresponding to that week.

```{r}
# Plot the seasonal plots at the weekly, monthly and quarterly level for all the years 

# Add columns for week, quarter, month and year 
songs_time_index_df <- cleaned_songs_df %>%  
  mutate(year = year(date), 
         quarter = quarter(date),
         month = month(date),
         week = week(date))

# Define the frequencies and their corresponding columns
frequencies <- c("week", "month", "quarter")
frequency_cols <- list(week = "week", month = "month", quarter = "quarter")

# Loop through each frequency and generate plots
for (freq in frequencies) {
  col_name <- frequency_cols[[freq]]
  
  # Aggregate data at the current frequency
  aggregated_data <- songs_time_index_df %>%
    group_by(year, !!sym(col_name)) %>%
    summarize(total_copies_sold = round(sum(copies_sold)))

  # Generate plot for the current frequency
  plot <- hchart(aggregated_data, "line", hcaes(x = !!sym(col_name), y =  total_copies_sold, group = year)) %>%
    hc_colors(colors = viridis(length(unique(aggregated_data$year)))) %>%
    hc_title(text = paste(toupper(freq), "Copies Sold by Year")) %>%
    hc_xAxis(title = list(text = toupper(freq)),
             labels = list(step = 2)) %>%
    hc_yAxis(title = list(text = "Total Copies Sold")) %>%
    hc_legend(title = list(text = "Year")) %>%
    hc_tooltip(crosshairs = TRUE, shared = TRUE) %>%
    hc_exporting(enabled = TRUE)
  
  # Print the plot
  print(plot)
}

```

#### 3.3 Check for temporal patterns across the continuous features

Findings:

-   All series appears to be quite stable across time where `total_energy`, `total_loudness` exhibit a slight downward trend.

-   All series exhibit a uptick at towards the end of the time series

-   There is high correlation among the features at every frequency.

```{r}
# Aggreate target and features at each frequency and plot 
# Create time series df at the monthly frequency
features_weekly_df <- cleaned_songs_df %>%
  mutate(date = format(date, "%Y-%W")) %>%
  group_by(date) %>%
  summarize(total_copies_sold = sum(copies_sold),
            total_loudness = sum(loudness),
            total_energy = sum(energy),
            total_length = sum(length)) %>%
  arrange(date) 

# Create time series df at the monthly frequency
features_monthly_df <- cleaned_songs_df %>%
  mutate(date = format(date, "%Y-%m")) %>%
  group_by(date) %>%
  summarize(total_copies_sold = sum(copies_sold),
            total_loudness = sum(loudness),
            total_energy = sum(energy),
            total_length = sum(length)) %>%
  arrange(date) 

# Create time series df at the quarterly frequency
features_quarterly_df <-cleaned_songs_df %>%
  mutate(date = paste0(year(date), "-Q", quarter(date))) %>%
  group_by(date) %>%
    summarize(total_copies_sold = sum(copies_sold),
            total_loudness = sum(loudness),
            total_energy = sum(energy),
            total_length = sum(length)) %>%
  arrange(date)

# Create a list to store the dataframes
features_list <- list(
  weekly = features_weekly_df,
  monthly = features_monthly_df,
  quarterly = features_quarterly_df
)

# Loop through the frequencies and create the plots
for (freq in names(features_list)) {
  features_df <- features_list[[freq]]  # Corrected variable name
  
  plot <- hchart(features_df, "line", hcaes(x = date, y = total_loudness), name = "Total Loudness") %>%
    hc_add_series(features_df, "line", hcaes(x = date, y = total_energy), name = "Total Energy") %>%
    hc_add_series(features_df, "line", hcaes(x = date, y = total_length), yAxis = 1, name = "Total Length") %>%
    hc_add_series(features_df, "line", hcaes(x = date, y = 10*total_copies_sold), yAxis = 1, name = "Total Copies Sold") %>%
    hc_title(text = paste("Features and target", freq)) %>%
    hc_xAxis(title = list(text = "Date")) %>%
    hc_yAxis_multiples(list(title = list(text = "Loudness/Energy"),
                            opposite = FALSE),
                       list(title = list(text = "Length/Copies Sold"),
                            opposite = TRUE)) %>%
    hc_tooltip(valueDecimals = 0)
  
  print(plot)
}
```

#### 3.4 Check the stability of the variable's distributions across time

-   To determine if the distributions of the continuous features are stable across the years, we generate violin of the continuous features for each year.
-   The distributions of all features appear stable over time, with little evidence of non-stationarity, which could potentially pose challenges during the modeling process.

```{r}
variables <- c("copies_sold","length","energy","loudness") 

# Plot the smoothed distributions of the continuous features for each year 
# for (vars in variables) {
#   plot <- ggplot(cleaned_songs_df, aes(x = !!sym(vars), fill = as.factor(year(date)))) +
#     geom_density(alpha = 0.5) +
#     ggtitle(paste("Density plot of", vars)) +
#     theme_minimal()
#   print(plot)
# }

# Plot the violin plots of each continuous feature for each year 
for (vars in variables) {
  plot <- plot_ly(cleaned_songs_df, x = ~as.factor(year(date)), y = ~get(vars), type = "violin",
                  box = list(visible = TRUE),
                  meanline = list(visible = TRUE),
                  hoverinfo = "text" ) %>%
    layout(title = paste("Violin Plot of", vars),
           xaxis = list(title = "Year"),
           yaxis = list(title = vars),
           showlegend = FALSE)
  print(plot)
}
```

#### 3.5 Investigate the relationship among the features and the target variable

**Check:** Investigate the correlation among features to understand feature importance.

**Findings**:

1.  The correlation among features appears to be low at the song level but high when aggregated at the weekly level.

    -   For Model A, which focuses on individual songs, we need to model at the song level.

    -   For Model B, which focuses on song genres, if modeling at the weekly frequency consider regularization or removing a feature to account for high multicollinearity.

2.  The 'length' feature exhibits low correlation with the target variable 'copies_sold' and other features at the song level.

3.  There is a negative relationship between 'copies_sold' and 'length' and 'loudness' at the song level. However, 'energy' shows a positive relationship with 'copies_sold' at the song level.

```{r}
# Calculate correlation matrix for continuous variables at different levels
# Correlation matrix at the song level 
correlation_matrix_song_level <- cor(cleaned_songs_df %>% select(all_of(variables)))

# Correlation matrix at the weekly level
correlation_matrix_weekly <- cor(features_weekly_df %>%  select(all_of(aggregated_variables)))

# Plot correlation matrices 
ggcorrplot(correlation_matrix_song_level, hc.order = TRUE, type = "upper",lab = TRUE)
ggcorrplot(correlation_matrix_weekly, hc.order = TRUE, type = "upper",lab = TRUE)

# Define the variables and their corresponding labels
plot_vars <- c("energy", "length", "loudness")
labels <- c("Energy", "Length", "Loudness")

# Loop through the variables and create the scatter plots
for (i in seq_along(plot_vars)) {
  var <- plot_vars[i]
  label <- labels[i]
  
  plot <- ggplot(data = cleaned_songs_df %>%  sample_n(2000),
                 aes(x = !!sym(var), y = copies_sold, color = genre, size = days_since_launch)) +
    geom_point(alpha = 0.7) +
    geom_smooth(method = "loess", formula = y ~ x, color = "black", size = 1) +
    scale_color_viridis(discrete = TRUE) +
    labs(x = label, y = "Copies Sold", title = paste("Scatter Plot of", label, "vs. Copies Sold")) +
    theme_minimal() +
    theme(
      plot.title = element_text(hjust = 0.5),
      legend.position = "bottom",
      legend.box = "vertical",
      legend.margin = margin(0, 0, 0, 0),
      legend.box.margin = margin(0, 0, 0, 0),
      legend.text = element_text(size = 8),
      legend.key.size = unit(0.5, "cm"),
      plot.margin = unit(c(1, 1, 1.5, 1), "cm")
    ) +
    guides(color = guide_legend(nrow = 2, byrow = TRUE, override.aes = list(size = 3)))
  
  print(plot)
}

```

#### 3.6 Investigate to existence of interaction effects between features and target variable

**Check:** Whether there is an interaction `energy` and `loudness` with `length` to `copies_sold`. Rationale: A song that is high energy/loud that is long may cause fatigue in listeners reducing copies sold.

The interaction plot provides visual evidence of interaction effect being present at energy and loudness. Considering testing interaction variables in a regression framework, or use a random forest regression to automatically capture interaction effects.

**Findings:**

```{r}
# Creating quartile bins for energy, loudness and length
interaction_df <- cleaned_songs_df %>%
  mutate(energy_bin = ntile(energy, 4),
         loudness_bin = ntile(loudness, 4),
         length_bin = ntile(length, 4))

# Create the interaction plot for loudness and energy
interaction.plot(x.factor = interaction_df$loudness_bin,
                 trace.factor = interaction_df$length_bin,
                 response = interaction_df$copies_sold,
                 fun = mean,
                 type = "b",
                 xlab = "Loudness",
                  col = c("blue", "red", "green", "purple"),
                 ylab = "Copies_sold",
                 legend = TRUE,
                 trace.label = "Length",
                 main = "Interaction Plot")

# Create the interaction plot for energy and length #
interaction.plot(x.factor = interaction_df$energy_bin,
                 trace.factor = as.factor(interaction_df$length_bin),
                response = interaction_df$copies_sold,
                 fun = mean,
                 type = "b",
                 xlab = "Energy",
                 col = c("blue", "red", "green", "purple"),
                 ylab = "Copies_sold",
                 legend = TRUE,
                 trace.label = "Length",
                 main = "Interaction Plot")
```

### 4.0 Feature engineering

We build the data set for models by creating the following features to experiment with

-   `log_y`: Log transformation of the target variable `copies_sold` given it's log-normal distribution
-   `days_since_release`: Day since release date of song
-   One hot encoding of the genre column
-   `interacion_loudness_length`: Interaction between energy and loudness
-   `interaction_energy_length`: Interaction between energy and length
-   `trend`: A trend variable corresponding to the days since start of data set

```{r}
# Assume record day of the data set
  record_date <- as.Date('2023-01-01')

# Create input data frame to experiment for model building 
model_input_df<- cleaned_songs_df %>%
  mutate(date = as.Date(date),
         days_since_release = as.integer(difftime(record_date, date, units = "days"))) %>%
  # Create day trend variable
  mutate(trend = as.integer(difftime(date, min(date), units = "days"))) %>% 
  # Create one hot encoding for the genre column
  mutate(value = 1) %>%
  pivot_wider(names_from = genre, values_from = value, values_fill = 0) %>%
  # Create interaction features
  mutate(interaction_loudness_length = loudness * length,
         interaction_energy_length = energy * length) %>%
  # Create log transformation of the target variable
  mutate(log_copies_sold = log(copies_sold)) 

model_input_df
  
```
